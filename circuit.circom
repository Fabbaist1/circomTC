pragma circom 2.0.0;

//

//

template MiMC5() {

    signal input x;
    signal input k;
    signal output h;
    
    var nRounds = 10; 

    var c[nRounds] = [
        0,
        71330665155220987139676911010213911991380613915442755982603904604783742482719,
        73056273978731281506109963288015827854315832075301281149555625754535369939118,
        112419453064266127791071955919590076649511494409036471343599747576135303790122,
        85004362269518790374977199767143347173792534234488565235938363627180397482641,
        86049359684269972072508133951024785229745437552355366584018081726826855729992,
        107332813439203924148859457783826599144448206273131939356032590337874052268194,
        20295222323643640601851627710501810686515255590463035920007432147940303552214,
        28267517906845961237901551562612627761878834329458572694369701827419659399239,
        28895351805838950241035621046761937308119637671129019276718397528678321420030
    ];

    signal LastOutput[nRounds + 1];
    var base[nRounds];
    signal base2[nRounds];
    signal base4[nRounds];

    LastOutput[0] <== x;

    for (var i = 0; i < nRounds; i++) {
        base[i] = LastOutput[i] + k + c[i];

        base2[i] <== base[i] * base[i];
        base4[i] <== base2[i] * base2[i];
        LastOutput[i+1] <== base4[i] * base[i];  
    }
    h <== LastOutput[nRounds] + k;


}

component main = MiMC5();